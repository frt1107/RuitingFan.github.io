---
layout: post
title:  "记华为二面的一道题"
date:   2020-07-13 21:30:00 +0800
categories: 面经
tag: 笔面试





---


* content
{:toc}




## 1. 介绍

华为二面出了道算法题，我当时没完全做出来。后来也问了几个同学和同事，大家也都没有完整的思路。也问了一个我认为是大神的在百度待过的大神，果然大神还是大神，完美解决。

## 2. 题目

用一个字符组表示CPU需要执行的任务列表，字母A-Z表示26种不同类型的任务。

任务以任意顺序调度执行，并且每个任务都在1个单位时间执行完。

CPU在任何一个单位时间内都可以执行一个任务，或者处于待命状态。

两个相同种类的任务之间必须要有长度为n的时间间隔，在这n个时间单位内CPU可以在执行不同的任务，或者处于待命状态。



你需要计算完成所有任务所需要的最短时间。

```
示例：
输入：tasks = ["A", "A", "A", "B", "B", "B"],n = 2
输出：8
执行顺序：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
```

注意：

总任务个数的取值范围是[1, 10000]。

间隔n的取值范围为[0, 100]。

## 3. 题解

先简化问题：

先不考虑各个任务数量不一致的情况，认为各种任务都有相同的任务数量。

那么，设：

```
k: 任务种类，k种任务
m: 每种任务有m个
n: 冷却时间
```

对任意的k，k有三种情况：

- k == n
- k < n
- k > n



------

### Step 1:

接下来对这几种情况分类讨论：

（1）k == n

也就是题目中的情况，["A", "A", "A", "B", "B", "B"]，其中，k = 2，n = 2， m = 3。

这种情况下，最短调度为：A -> B -> (待命) -> A -> B -> (待命) -> A -> B。



将每个“A -> B -> (待命)”视为一个时间块，则时间块的最小单位是n + 1

，也就是每个时间块长度为n + 1。

**那么，这种情况下的最短调度时间为：m * k + (m - 1)：**

m * k是指每个时间块中，都会占k个时间片，一共有m个时间块。

m - 1是指需要将前m - 1个时间块中，每个时间块补全一个时间片的CPU（待命）状态。

因此，总调度时间是m * k + (m - 1)。



（2）k < n

假设["A", "A", "A", "B", "B", "B"]，其中，k = 2，n = 3， m = 3。注意这里和（1）中不同的是n = 3。

这种情况下，最短调度为：A -> B -> (待命) -> (待命) -> A -> B -> (待命) -> (待命) -> A -> B。



由于n = 3，那么每个时间块长度n + 1，也就是4，也就是每个“A -> B -> (待命) -> (待命) ”是一个时间块。

很明显每个时间块里插入的CPU（待命）的时间片数为n - k + 1。

**那么，这种情况下的最短调度时间为：m * k + (m - 1) * （n - k + 1）**



（3）k > n（k >= n + 1）

假设["A", "A", "B", "B", "C", "C"]，其中，k = 3，n = 2， m = 2。

这种情况下，最短调度为：A -> B -> C-> A -> B -> C。

时间块长度为3，3种任务，时间块的每个时间片都能充分利用。

**那么，这种情况下的最短调度时间为：m * k**



------

### Step 2：

上述是将每种种类的任务数量都视为一样，题目中的情况则是每种任务的任务数量不一致的情况。

那么这种就只需要循环每次将所有种类的任务向具有最小任务数量的任务对齐即可。

如：["A", "A", "A", "A", "B", "B", "B", "C", "C"]，其中，k = 3, n = 3。

（1）A有4个，B有3个，C有2个。

则向C（2个）对齐，也就是视作["A", "A", "B", "B", "C", "C"]，

k = 3, n = 3, m = 2。

调度时间为：m * k + (m - 1) = 7

（2）A剩2个，B剩1个。

则向B（1个）对齐，也就是视作["A", "B"]，k = 2, n = 3, m = 1。

调度时间为：m * k + (m - 1) * （n - k + 1）= 2

（3）A剩1个。

调度时间为1。



------

### Step 3：

不知道大家有没有发现上述对齐处理的问题：

慢慢分析下，将（1）（2）（3）三步连起来，调度情况就是：

A -> B -> C -> (待命) -> A -> B -> C `*| （第（1）步结束，用了7个时间片）|*` -> A -> B `| （第（2）步结束，用了2个时间片）|` -> A  `*| （第（3）步结束，用了1个时间片）|*` 

那么总共用了：7 + 2 + 1个时间片。

**对吗？不对。**

原因在于：

之前的计算公式中，把最后一个时间块需要插入的CPU（待命）的时间块都没计算入内。

解决方法：

修改计算公式：

- 如果当前不是最后1次循环的话，把之前去掉的最后1个时间片都加回来，也就是对k <= n这两种情况，调度时间为：**m * k + m * （n - k + 1）= m * (n + 1)**
- 如果当前说最后1次循环，则按之前去掉最后1个时间片的方法计算，把插入调度序列末尾的CPU（待命）时间片都去掉。

